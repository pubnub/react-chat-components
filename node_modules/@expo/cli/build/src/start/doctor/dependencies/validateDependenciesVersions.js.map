{"version":3,"sources":["../../../../../src/start/doctor/dependencies/validateDependenciesVersions.ts"],"sourcesContent":["import { ExpoConfig, PackageJSONConfig } from '@expo/config';\nimport JsonFile from '@expo/json-file';\nimport assert from 'assert';\nimport chalk from 'chalk';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\n\nimport * as Log from '../../../log';\nimport { CommandError } from '../../../utils/errors';\nimport { BundledNativeModules } from './bundledNativeModules';\nimport { getCombinedKnownVersionsAsync } from './getVersionedPackages';\n\nconst debug = require('debug')('expo:doctor:dependencies:validate') as typeof console.log;\n\ninterface IncorrectDependency {\n  packageName: string;\n  expectedVersionOrRange: string;\n  actualVersion: string;\n}\n\n/**\n * Print a list of incorrect dependency versions.\n *\n * @param projectRoot Expo project root.\n * @param exp Expo project config.\n * @param pkg Project's `package.json`.\n * @param packagesToCheck A list of packages to check, if undefined or empty, all will be checked.\n * @returns `true` if there are no incorrect dependencies.\n */\nexport async function validateDependenciesVersionsAsync(\n  projectRoot: string,\n  exp: Pick<ExpoConfig, 'sdkVersion'>,\n  pkg: PackageJSONConfig,\n  packagesToCheck?: string[]\n): Promise<boolean> {\n  const incorrectDeps = await getVersionedDependenciesAsync(projectRoot, exp, pkg, packagesToCheck);\n  return logIncorrectDependencies(incorrectDeps);\n}\n\nfunction logInvalidDependency({\n  packageName,\n  expectedVersionOrRange,\n  actualVersion,\n}: IncorrectDependency) {\n  Log.warn(\n    // chalk` - {underline ${packageName}} - expected version: {underline ${expectedVersionOrRange}} - actual version installed: {underline ${actualVersion}}`\n    chalk`  {bold ${packageName}}{cyan @}{red ${actualVersion}} - expected version: {green ${expectedVersionOrRange}}`\n  );\n}\n\nexport function logIncorrectDependencies(incorrectDeps: IncorrectDependency[]) {\n  if (!incorrectDeps.length) {\n    return true;\n  }\n\n  Log.warn(chalk`Some dependencies are incompatible with the installed {bold expo} version:`);\n  incorrectDeps.forEach((dep) => logInvalidDependency(dep));\n\n  const requiredVersions = incorrectDeps.map(\n    ({ packageName, expectedVersionOrRange }) => `${packageName}@${expectedVersionOrRange}`\n  );\n\n  Log.warn(\n    'Your project may not work correctly until you install the correct versions of the packages.\\n' +\n      chalk`Install individual packages by running {inverse npx expo install ${requiredVersions.join(\n        ' '\n      )}}`\n  );\n  return false;\n}\n\n/**\n * Return a list of versioned dependencies for the project SDK version.\n *\n * @param projectRoot Expo project root.\n * @param exp Expo project config.\n * @param pkg Project's `package.json`.\n * @param packagesToCheck A list of packages to check, if undefined or empty, all will be checked.\n * @returns A list of incorrect dependencies.\n */\nexport async function getVersionedDependenciesAsync(\n  projectRoot: string,\n  exp: Pick<ExpoConfig, 'sdkVersion'>,\n  pkg: PackageJSONConfig,\n  packagesToCheck?: string[]\n): Promise<IncorrectDependency[]> {\n  // This should never happen under normal circumstances since\n  // the CLI is versioned in the `expo` package.\n  assert(exp.sdkVersion, 'SDK Version is missing');\n\n  // Get from both endpoints and combine the known package versions.\n  const combinedKnownPackages = await getCombinedKnownVersionsAsync({\n    projectRoot,\n    sdkVersion: exp.sdkVersion,\n  });\n  // debug(`Known dependencies: %O`, combinedKnownPackages);\n\n  const resolvedDependencies = packagesToCheck?.length\n    ? // Diff the provided packages to ensure we only check against installed packages.\n      getFilteredObject(packagesToCheck, { ...pkg.dependencies, ...pkg.devDependencies })\n    : // If no packages are provided, check against the `package.json` `dependencies` object.\n      pkg.dependencies;\n  debug(`Checking dependencies for ${exp.sdkVersion}: %O`, resolvedDependencies);\n\n  // intersection of packages from package.json and bundled native modules\n  const { known: resolvedPackagesToCheck, unknown } = getPackagesToCheck(\n    resolvedDependencies,\n    combinedKnownPackages\n  );\n  debug(`Comparing known versions: %O`, resolvedPackagesToCheck);\n  debug(`Skipping packages that cannot be versioned automatically: %O`, unknown);\n  // read package versions from the file system (node_modules)\n  const packageVersions = await resolvePackageVersionsAsync(projectRoot, resolvedPackagesToCheck);\n  debug(`Package versions: %O`, packageVersions);\n  // find incorrect dependencies by comparing the actual package versions with the bundled native module version ranges\n  const incorrectDeps = findIncorrectDependencies(packageVersions, combinedKnownPackages);\n  debug(`Incorrect dependencies: %O`, incorrectDeps);\n\n  return incorrectDeps;\n}\n\nfunction getFilteredObject(keys: string[], object: Record<string, string>) {\n  return keys.reduce<Record<string, string>>((acc, key) => {\n    acc[key] = object[key];\n    return acc;\n  }, {});\n}\n\nfunction getPackagesToCheck(\n  dependencies: Record<string, string> | null | undefined,\n  bundledNativeModules: BundledNativeModules\n): { known: string[]; unknown: string[] } {\n  const dependencyNames = Object.keys(dependencies ?? {});\n  const known: string[] = [];\n  const unknown: string[] = [];\n  for (const dependencyName of dependencyNames) {\n    if (dependencyName in bundledNativeModules) {\n      known.push(dependencyName);\n    } else {\n      unknown.push(dependencyName);\n    }\n  }\n  return { known, unknown };\n}\n\nasync function resolvePackageVersionsAsync(\n  projectRoot: string,\n  packages: string[]\n): Promise<Record<string, string>> {\n  const packageVersionsFromPackageJSON = await Promise.all(\n    packages.map((packageName) => getPackageVersionAsync(projectRoot, packageName))\n  );\n  return packages.reduce((acc, packageName, idx) => {\n    acc[packageName] = packageVersionsFromPackageJSON[idx];\n    return acc;\n  }, {} as Record<string, string>);\n}\n\nasync function getPackageVersionAsync(projectRoot: string, packageName: string): Promise<string> {\n  let packageJsonPath: string | undefined;\n  try {\n    packageJsonPath = resolveFrom(projectRoot, `${packageName}/package.json`);\n  } catch (error: any) {\n    // This is a workaround for packages using `exports`. If this doesn't\n    // include `package.json`, we have to use the error message to get the location.\n    if (error.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n      packageJsonPath = error.message.match(/(\"exports\"|defined) in (.*)$/i)?.[2];\n    }\n  }\n  if (!packageJsonPath) {\n    throw new CommandError(\n      `\"${packageName}\" is added as a dependency in your project's package.json but it doesn't seem to be installed. Please run \"yarn\" or \"npm install\" to fix this issue.`\n    );\n  }\n  const packageJson = await JsonFile.readAsync<BundledNativeModules>(packageJsonPath);\n  return packageJson.version;\n}\n\nfunction findIncorrectDependencies(\n  packageVersions: Record<string, string>,\n  bundledNativeModules: BundledNativeModules\n): IncorrectDependency[] {\n  const packages = Object.keys(packageVersions);\n  const incorrectDeps: IncorrectDependency[] = [];\n  for (const packageName of packages) {\n    const expectedVersionOrRange = bundledNativeModules[packageName];\n    const actualVersion = packageVersions[packageName];\n    if (\n      typeof expectedVersionOrRange === 'string' &&\n      !semver.intersects(expectedVersionOrRange, actualVersion)\n    ) {\n      incorrectDeps.push({\n        packageName,\n        expectedVersionOrRange,\n        actualVersion,\n      });\n    }\n  }\n  return incorrectDeps;\n}\n"],"names":["validateDependenciesVersionsAsync","logIncorrectDependencies","getVersionedDependenciesAsync","Log","debug","require","projectRoot","exp","pkg","packagesToCheck","incorrectDeps","logInvalidDependency","packageName","expectedVersionOrRange","actualVersion","warn","chalk","length","forEach","dep","requiredVersions","map","join","assert","sdkVersion","combinedKnownPackages","getCombinedKnownVersionsAsync","resolvedDependencies","getFilteredObject","dependencies","devDependencies","known","resolvedPackagesToCheck","unknown","getPackagesToCheck","packageVersions","resolvePackageVersionsAsync","findIncorrectDependencies","keys","object","reduce","acc","key","bundledNativeModules","dependencyNames","Object","dependencyName","push","packages","packageVersionsFromPackageJSON","Promise","all","getPackageVersionAsync","idx","packageJsonPath","resolveFrom","error","code","message","match","CommandError","packageJson","JsonFile","readAsync","version","semver","intersects"],"mappings":"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"}