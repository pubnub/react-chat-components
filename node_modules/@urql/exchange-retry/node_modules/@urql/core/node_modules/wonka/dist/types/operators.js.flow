// @flow

import type { Source, Operator } from "./types";
declare export function buffer<S, T>(notifier: Source<S>): Operator<T, T[]>;
declare export function combine<A, B>(
  sourceA: Source<A>,
  sourceB: Source<B>
): Source<[A, B]>;
declare export function concatMap<In, Out>(
  map: (value: In) => Source<Out>
): Operator<In, Out>;
declare export function concatAll<T>(source: Source<Source<T>>): Source<T>;
declare export function concat<T>(sources: Source<T>[]): Source<T>;
declare export function filter<T>(
  predicate: (value: T) => boolean
): Operator<T, T>;
declare export function map<In, Out>(
  map: (value: In) => Out
): Operator<In, Out>;
declare export function mergeMap<In, Out>(
  map: (value: In) => Source<Out>
): Operator<In, Out>;
declare export function mergeAll<T>(source: Source<Source<T>>): Source<T>;
declare export function merge<T>(sources: Source<T>[]): Source<T>;
declare export function onEnd<T>(callback: () => void): Operator<T, T>;
declare export function onPush<T>(callback: (value: T) => void): Operator<T, T>;
declare export function onStart<T>(callback: () => void): Operator<T, T>;
declare export function sample<S, T>(notifier: Source<S>): Operator<T, T>;
declare export function scan<In, Out>(
  reducer: (acc: Out, value: In) => Out,
  seed: Out
): Operator<In, Out>;
declare export function share<T>(source: Source<T>): Source<T>;
declare export function skip<T>(wait: number): Operator<T, T>;
declare export function skipUntil<S, T>(notifier: Source<S>): Operator<T, T>;
declare export function skipWhile<T>(
  predicate: (value: T) => boolean
): Operator<T, T>;
declare export function switchMap<In, Out>(
  map: (value: In) => Source<Out>
): Operator<In, Out>;
declare export function switchAll<T>(source: Source<Source<T>>): Source<T>;
declare export function take<T>(max: number): Operator<T, T>;
declare export function takeLast<T>(max: number): Operator<T, T>;
declare export function takeUntil<S, T>(notifier: Source<S>): Operator<T, T>;
declare export function takeWhile<T>(
  predicate: (value: T) => boolean
): Operator<T, T>;
declare export function debounce<T>(
  timing: (value: T) => number
): Operator<T, T>;
declare export function delay<T>(wait: number): Operator<T, T>;
declare export function throttle<T>(
  timing: (value: T) => number
): Operator<T, T>;
declare export { mergeAll as flatten, onPush as tap };
