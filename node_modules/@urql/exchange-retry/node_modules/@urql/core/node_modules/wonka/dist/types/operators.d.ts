import { Source, Operator } from './types';
export declare function buffer<S, T>(notifier: Source<S>): Operator<T, T[]>;
export declare function combine<A, B>(sourceA: Source<A>, sourceB: Source<B>): Source<[A, B]>;
export declare function concatMap<In, Out>(map: (value: In) => Source<Out>): Operator<In, Out>;
export declare function concatAll<T>(source: Source<Source<T>>): Source<T>;
export declare function concat<T>(sources: Source<T>[]): Source<T>;
export declare function filter<T>(predicate: (value: T) => boolean): Operator<T, T>;
export declare function map<In, Out>(map: (value: In) => Out): Operator<In, Out>;
export declare function mergeMap<In, Out>(map: (value: In) => Source<Out>): Operator<In, Out>;
export declare function mergeAll<T>(source: Source<Source<T>>): Source<T>;
export declare function merge<T>(sources: Source<T>[]): Source<T>;
export declare function onEnd<T>(callback: () => void): Operator<T, T>;
export declare function onPush<T>(callback: (value: T) => void): Operator<T, T>;
export declare function onStart<T>(callback: () => void): Operator<T, T>;
export declare function sample<S, T>(notifier: Source<S>): Operator<T, T>;
export declare function scan<In, Out>(reducer: (acc: Out, value: In) => Out, seed: Out): Operator<In, Out>;
export declare function share<T>(source: Source<T>): Source<T>;
export declare function skip<T>(wait: number): Operator<T, T>;
export declare function skipUntil<S, T>(notifier: Source<S>): Operator<T, T>;
export declare function skipWhile<T>(predicate: (value: T) => boolean): Operator<T, T>;
export declare function switchMap<In, Out>(map: (value: In) => Source<Out>): Operator<In, Out>;
export declare function switchAll<T>(source: Source<Source<T>>): Source<T>;
export declare function take<T>(max: number): Operator<T, T>;
export declare function takeLast<T>(max: number): Operator<T, T>;
export declare function takeUntil<S, T>(notifier: Source<S>): Operator<T, T>;
export declare function takeWhile<T>(predicate: (value: T) => boolean): Operator<T, T>;
export declare function debounce<T>(timing: (value: T) => number): Operator<T, T>;
export declare function delay<T>(wait: number): Operator<T, T>;
export declare function throttle<T>(timing: (value: T) => number): Operator<T, T>;
export { mergeAll as flatten, onPush as tap };
