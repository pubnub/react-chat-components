import * as O from 'optics-ts';
import { SetStateAction, WritableAtom } from 'jotai';
declare type NonFunction<T> = [
    T
] extends [
    (...args: any[]) => any
] ? never : T;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<Promise<S>, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Prism<S, any, A>): WritableAtom<A | undefined, SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<Promise<S>, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Traversal<S, any, A>): WritableAtom<A[], SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<Promise<S>, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<A, SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<S, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Prism<S, any, A>): WritableAtom<A | undefined, SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<S, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Traversal<S, any, A>): WritableAtom<A[], SetStateAction<A>, R>;
export declare function focusAtom<S, A, R extends void | Promise<void>>(baseAtom: WritableAtom<S, NonFunction<S>, R>, callback: (optic: O.OpticFor<S>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<A, SetStateAction<A>, R>;
export {};
declare type Awaited<T> = T extends Promise<infer V> ? V : T;